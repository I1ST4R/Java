<!DOCTYPE html>
<html lang="ru" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Расписание тренера</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <style>
        body {
            background-color: #f8f9fa; /* Слегка серый фон для всей страницы */
        }
        .navbar {
            margin-bottom: 1.5rem;
        }
        .page-container {
            padding: 1rem;
        }
        .day-card {
            width: 100%; /* Карточка дня занимает всю доступную ширину */
            margin-bottom: 1.5rem; /* Отступ снизу между карточками дней */
            border: 1px solid #dee2e6;
            border-radius: 0.75rem;
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        .day-card-header {
            padding: 1rem 1.25rem;
            background-color: #e9ecef;
            border-bottom: 1px solid #dee2e6;
            border-top-left-radius: 0.75rem;
            border-top-right-radius: 0.75rem;
        }
        .day-card-header h5 {
            margin-bottom: 0;
            font-size: 1.25rem; /* Увеличен шрифт для даты */
            font-weight: 500;
        }
        .today-highlight .day-card-header {
            background-color: #0d6efd;
            color: white;
            border-color: #0a58ca;
        }
        .today-highlight {
             border: 2px solid #0d6efd;
             box-shadow: 0 6px 12px rgba(13,110,253,0.3);
        }
        .day-card-body {
            padding: 1.25rem;
        }
        .timeline-wrapper {
            margin-bottom: 1rem;
        }
        .timeline-container {
            position: relative;
            height: 90px; /* Уменьшил немного, чтобы панелька поместилась ниже */
            border-radius: 0.375rem;
            overflow: hidden;
            cursor: pointer; /* Показываем, что по таймлайну можно кликать */
        }
        .timeline-hours {
            position: absolute;
            top: 0;
            left: 0px;
            right: 0;
            height: 30px; 
            display: flex;
            font-size: 0.8rem; 
            border-bottom: 1px solid #ced4da;
        }
        .timeline-hours .hour-mark, .timeline-hours .half-hour-mark {
            flex-grow: 1;
            text-align: left; /* Для half-hour-mark оставляем центр */
            /* padding-top: 5px; Убрано, т.к. текста часа не будет */ 
            position: relative; 
            box-sizing: border-box;
            height: 100%; /* Чтобы ::before мог позиционироваться относительно всей высоты */
        }
        .timeline-hours .hour-mark span {
            display: inline-block;
            /* width: 100%; */ 
            /* text-align: left; */ /* Убрано для центрирования */
            /* padding-left: 2px; */ /* Убрано для центрирования */
            font-size: 15px; 
            line-height: 1; 
            position: relative; 
        }
        .timeline-hours .hour-mark:first-child, .timeline-hours .half-hour-mark:first-child {
            border-left: none;
        }
        /* Линии для отметок */
        .timeline-hours .hour-mark::before, .timeline-hours .half-hour-mark::before {
            content: '';
            position: absolute;
            bottom: -60px; /* height of timeline-intervals */
            left: 0; /* или 50% для центрирования, если сама отметка узкая */
            width: 1px;
            height: 60px; 
            background-color: #d0d2d5; 
        }

        .hour-mark-end{
            position: absolute;
            top: 2px !important;
            right:-20px !important;
        }

        .timeline-hours .half-hour-mark::before {
            background-color: #e0e2e5; /* Менее заметные линии для получасов */
        }
        .timeline-intervals {
            position: absolute;
            border-bottom: 1px solid #ced4da;
            border-right: 1px solid #ced4da;
            top: 30px; 
            left: 0;
            right: 0;
            height: 60px; 
        }
        .timeline-interval-block {
            position: absolute;
            height: 85%; 
            top: 7.5%;
            border-radius: 0.375rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem; 
            font-weight: 500;
            padding: 0 5px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            box-sizing: border-box; 
            border: 1px solid rgba(0,0,0,0.15); /* Возвращаем базовую рамку */
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            z-index: 10; /* Чтобы был поверх временных слотов для кликов, если они будут */
        }
        .status-undefined { background-color: #ffc107; color: #212529; border-color: #e0a800;}
        .status-available { background-color: #198754; color: white; border-color: #146c43;}
        .status-unavailable { background-color: #dc3545; color: white; border-color: #b02a37;}
        .status-booked { background-color: #fd7e14; color: white; border-color: #e66a00; }

        /* Временный слот для выделения */
        .temp-selection-slot {
            position: absolute;
            height: 100%;
            /* background-color: rgba(108, 117, 125, 0.3); убираем, будет через класс или прямой стиль */
            /* border: 1px dashed #6c757d; убираем */
            box-sizing: border-box;
            z-index: 5;
            pointer-events: none; /* Не перехватывать клики */
        }
        .temp-gray-selection {
            background-color: rgba(108, 117, 125, 0.5) !important; /* Серый полупрозрачный */
            border: 1px dashed #6c757d !important;
        }

        /* Панель управления интервалом */
        .interval-controls {
            display: none; /* Скрыта по умолчанию */
            padding: 0.75rem;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-top: none; /* Без верхней рамки, если примыкает к таймлайну */
            border-bottom-left-radius: 0.375rem;
            border-bottom-right-radius: 0.375rem;
            margin-top: -1px; /* Чтобы примкнуть к таймлайну */
        }
        .interval-controls .btn-group .btn {
            margin-right: 5px;
        }
        .interval-controls .btn-group .btn:last-child {
            margin-right: 0;
        }
        .interval-controls textarea {
            font-size: 0.9rem;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .btn-status-available { background-color: #198754; color:white; }
        .btn-status-unavailable { background-color: #dc3545; color:white; }
        .btn-status-undefined { background-color: #ffc107; color:#212529; }

    </style>
</head>
<body>
    <!-- Навигационное меню -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand" href="/">Фитнес-клуб</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/"><i class="bi bi-house-door"></i> Главная</a>
                    </li>
                    <li sec:authorize="hasRole('ROLE_TRAINER')" class="nav-item">
                        <a class="nav-link" th:href="@{/trainer/profile}"><i class="bi bi-person"></i> Мой профиль</a>
                    </li>
                    <li sec:authorize="hasRole('ROLE_TRAINER')" class="nav-item">
                        <a class="nav-link active" th:href="@{/trainer/schedule}"><i class="bi bi-calendar-week"></i> Моё расписание</a>
                    </li>
                </ul>
                <a sec:authorize="isAuthenticated()" href="/logout" class="btn btn-outline-light"><i class="bi bi-box-arrow-right"></i> Выйти</a>
            </div>
        </div>
    </nav>

    <div class="container page-container">
        <h1 class="mb-3 h3">Моё расписание <span class="h5 text-muted" th:text="'(Тренер: ' + ${trainer.firstName} + ' ' + ${trainer.lastName} + ')'"></span></h1>
        
        <div class="alert alert-info mb-4">
            <strong>Инструкция:</strong>
            <ul>
                <li>Кликните на таймлайне на желаемое 30-минутное начало интервала. Слот подсветится.</li>
                <li>Для выбора диапазона, после первого клика, кликните на другой 30-минутный слот. Весь диапазон подсветится.</li>
                <li>Используйте появившуюся панель для выбора статуса (цвета) и добавления описания. Нажмите "Сохранить".</li>
                <li>Для редактирования существующего интервала, кликните прямо на него.</li>
            </ul>
        </div>
        
        <div> 
            <div th:each="schedule, schedStat : ${schedules}" 
                 class="day-card"
                 th:classappend="${schedule.date.equals(today)} ? 'today-highlight' : ''"
                 th:attr="data-date=${#temporals.format(schedule.date, 'yyyy-MM-dd')}">
                
                <div class="day-card-header">
                    <h5 th:text="${#strings.capitalize(#temporals.format(schedule.date, 'EEEE')) + ', ' + #temporals.format(schedule.date, 'dd MMMM yyyy')}"></h5>
                </div>
                
                <div class="day-card-body">
                    <div class="timeline-wrapper">
                        <div class="timeline-container" th:id="'timelineContainer-' + ${schedStat.index}">
                            
                            <div class="timeline-hours">
                                <!-- 14 часов * 2 отметки/час = 28 отметок. Восстанавливаем для линий сетки. -->
                                <th:block th:each="i : ${#numbers.sequence(0, 27)}">
                                    <div th:class="${i % 2 == 0} ? 'hour-mark' : 'half-hour-mark'"
                                         th:style="'width: ' + (100.0 / 28) + '%;'">
                                        <!-- Текстовые метки часов 8-21 -->
                                        <span th:if="${i % 2 == 0 && (8 + (i / 2)) < 22}" th:text="${#numbers.formatInteger(8 + (i / 2), 0)}"></span>
                                    </div>
                                </th:block>
                                <!-- Метка для 22:00 -->
                                <div class="hour-mark-end" style="position: absolute; top: 0; right: 0; transform: translateX(-100%); padding-right: 3px; font-size: 15px; line-height: 1;">22</div>
                            </div>
                            
                            <div class="timeline-intervals" th:id="'timelineIntervals-' + ${schedStat.index}">
                                <!-- Существующие интервалы -->
                                <th:block th:each="interval : ${schedule.intervals}">
                                    <th:block th:with="
                                        totalTimelineMinutes = (22 - 8) * 60, 
                                        startHour = ${interval.startTime.getHour()},
                                        startMinute = ${interval.startTime.getMinute()},
                                        endHour = ${interval.endTime.getHour()},
                                        endMinute = ${interval.endTime.getMinute()},
                                        intervalStartOffsetMinutes = (${startHour} - 8) * 60 + ${startMinute},
                                        intervalEndOffsetMinutes = (${endHour} - 8) * 60 + ${endMinute},
                                        leftPercentage = (${intervalStartOffsetMinutes} * 100.0) / ${totalTimelineMinutes},
                                        widthPercentage = ((${intervalEndOffsetMinutes} - ${intervalStartOffsetMinutes}) * 100.0) / ${totalTimelineMinutes}
                                    ">
                                    <div th:class="'timeline-interval-block'"
                                         th:classappend="${'status-' + #strings.toLowerCase(interval.status.toString())}"
                                         th:style="'left: ' + ${leftPercentage} + '%; width: ' + ${widthPercentage} + '%;'"
                                         th:data-interval-id="${interval.id}"
                                         th:data-start-time="${#temporals.format(interval.startTime, 'HH:mm')}"
                                         th:data-end-time="${#temporals.format(interval.endTime, 'HH:mm')}"
                                         th:data-status="${interval.status.name()}"
                                         th:data-description="${interval.description != null ? interval.description : ''}"
                                         th:title="${#temporals.format(interval.startTime, 'HH:mm')} + ' - ' + ${#temporals.format(interval.endTime, 'HH:mm')} + ' (' + ${interval.status.name()} + ')' + (${interval.description != null && !interval.description.isEmpty()} ? ': ' + interval.description : '')">
                                         <th:block th:with="
                                            sH = ${interval.startTime.getHour()}, sM = ${interval.startTime.getMinute()},
                                            eH = ${interval.endTime.getHour()}, eM = ${interval.endTime.getMinute()},
                                            startTotalMin = ${sH * 60 + sM},
                                            endTotalMin = ${eH * 60 + eM},
                                            durationMin = ${endTotalMin - startTotalMin},
                                            durH = ${T(java.lang.Math).floor(durationMin / 60.0)},
                                            durM = ${durationMin % 60}
                                        ">
                                            <span th:text="${durH == 0 && durM == 0 ? '0:00' : (durM == 0 ? durH : durH + ':' + (durM < 10 ? '0' : '') + durM)}"></span>
                                        </th:block>
                                    </div>
                                    </th:block>
                                </th:block>
                                <!-- Временный слот для выделения (будет управляться JS) -->
                                <div class="temp-selection-slot" style="display: none;"></div>
                            </div>
                        </div>
                        <!-- Панель управления (одна на страницу, позиционируется JS) -->
                        <div class="interval-controls" th:id="'intervalControls-' + ${schedStat.index}">
                            <div class="btn-group btn-group-sm mb-2" role="group">
                                <button type="button" class="btn btn-status-available" data-status="AVAILABLE">Доступен</button>
                                <button type="button" class="btn btn-status-unavailable" data-status="UNAVAILABLE">Недоступен</button>
                                <button type="button" class="btn btn-status-undefined" data-status="UNDEFINED">Не&nbsp;опред.</button>
                            </div>
                            <textarea class="form-control form-control-sm" rows="2" placeholder="Описание..."></textarea>
                            <div class="mt-2">
                                <button type="button" class="btn btn-primary btn-sm me-2 action-save">Сохранить</button>
                                <button type="button" class="btn btn-danger btn-sm me-2 action-delete" style="display:none;">Удалить</button>
                                <button type="button" class="btn btn-secondary btn-sm action-cancel">Отмена</button>
                            </div>
                        </div>
                    </div> 
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script th:inline="javascript">
        /*<![CDATA[*/
        const csrfToken = /*[[${_csrf != null ? _csrf.token : null}]]*/ null;
        const csrfHeaderName = /*[[${_csrf != null ? _csrf.headerName : null}]]*/ null;
        const schedulesData = /*[[${schedules}]]*/ []; // Данные для проверки пересечений и др.
        const trainerId = /*[[${trainer.id}]]*/ null;

        const TIMELINE_START_HOUR = 8;
        const TIMELINE_END_HOUR = 22;
        const SLOTS_PER_HOUR = 2; // 30-минутные слоты

        let activeSelection = null; 
        // Структура activeSelection:
        // { 
        //   date: String, 
        //   startTime: String, // "HH:mm"
        //   endTime: String,   // "HH:mm"
        //   selectionPhase: String, // 'slot_selected', 'color_picked'
        //   status: String, // 'AVAILABLE', 'UNAVAILABLE', 'UNDEFINED' (после выбора цвета)
        //   description: String,
        //   intervalId: Number, // для существующих интервалов
        //   dayCardElement: DOMElement, 
        //   tempSlotElement: DOMElement, 
        //   controlsPanel: DOMElement,
        //   isExisting: Boolean 
        // }

        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.day-card').forEach(dayCard => {
                const timelineContainer = dayCard.querySelector('.timeline-container');
                const timelineIntervals = dayCard.querySelector('.timeline-intervals');
                const controlsPanel = dayCard.querySelector('.interval-controls');
                const tempSelectionDiv = timelineIntervals.querySelector('.temp-selection-slot');
                const date = dayCard.dataset.date;

                // Клик по области интервалов (для создания новых или выбора диапазона)
                timelineIntervals.addEventListener('click', (event) => {
                    if (event.target.classList.contains('timeline-interval-block')) {
                        // Клик на существующий блок - обработка ниже
                        handleExistingIntervalClick(event.target, date, dayCard, controlsPanel, tempSelectionDiv);
                        return;
                    }

                    const rect = timelineIntervals.getBoundingClientRect();
                    const clickX = event.clientX - rect.left;
                    const percentageX = (clickX / rect.width) * 100;
                    
                    const totalSlots = (TIMELINE_END_HOUR - TIMELINE_START_HOUR) * SLOTS_PER_HOUR;
                    const slotIndex = Math.floor(percentageX / (100 / totalSlots));
                    
                    let slotStartHour = TIMELINE_START_HOUR + Math.floor(slotIndex / SLOTS_PER_HOUR);
                    let slotStartMinute = (slotIndex % SLOTS_PER_HOUR) * (60 / SLOTS_PER_HOUR);
                    const slotStartTimeStr = String(slotStartHour).padStart(2, '0') + ':' + String(slotStartMinute).padStart(2, '0');

                    let slotEndHour = slotStartHour;
                    let slotEndMinute = slotStartMinute + (60 / SLOTS_PER_HOUR);
                    if (slotEndMinute >= 60) {
                        slotEndHour++;
                        slotEndMinute %= 60;
                    }
                    // Предотвращение выхода за TIMELINE_END_HOUR
                    if (slotEndHour >= TIMELINE_END_HOUR && slotEndMinute > 0) {
                        slotEndHour = TIMELINE_END_HOUR;
                        slotEndMinute = 0;
                    }
                     if (slotStartHour >= TIMELINE_END_HOUR) { // Клик за пределами рабочего времени
                        console.log("Клик за пределами рабочего времени");
                        return;
                    }

                    const slotEndTimeStr = String(slotEndHour).padStart(2, '0') + ':' + String(slotEndMinute).padStart(2, '0');

                    if (!activeSelection || activeSelection.date !== date || activeSelection.selectionPhase === 'color_picked') {
                        // Первый клик, или клик на другом дне, или после выбора цвета (начинаем новый выбор)
                        resetActiveSelection(); 
                        activeSelection = {
                            date: date,
                            startTime: slotStartTimeStr,
                            endTime: slotEndTimeStr,
                            selectionPhase: 'slot_selected',
                            isExisting: false,
                            dayCardElement: dayCard,
                            tempSlotElement: tempSelectionDiv,
                            controlsPanel: controlsPanel
                        };
                        highlightTempSelection('gray'); // Новый параметр для цвета подсветки
                        showControlsPanelForSlotSelection();
                    } else if (activeSelection.selectionPhase === 'slot_selected') {
                        // Второй клик на том же дне, в фазе выбора слота - формируем диапазон
                        // Определяем начало и конец диапазона
                        const firstClickStartTime = activeSelection.startTime;
                        let newStartTime, newEndTime;

                        // Сравниваем время начала текущего клика (slotStartTimeStr) 
                        // с временем начала первого клика (firstClickStartTime)
                        if (slotStartTimeStr < firstClickStartTime) {
                            newStartTime = slotStartTimeStr;
                            newEndTime = activeSelection.endTime; // Конец первого выделенного слота
                             // Если второй клик раньше первого, то endTime первого слота должен стать endTime диапазона
                            // startTime нового клика становится startTime диапазона
                            // endTime старого startTime (activeSelection.startTime) должен стать новым endTime
                            // Это значит, что мы расширяем влево, endTime текущего клика slotEndTimeStr становится новым endTime
                            const tempEndTime = activeSelection.startTime; // Начало первого клика - это конец второго слота в первоначальном выделении
                            
                            // Вычисляем endTime для первого клика (который теперь будет концом диапазона)
                             let [h, m] = tempEndTime.split(':').map(Number);
                             m += (60 / SLOTS_PER_HOUR);
                             if (m>=60) { h++; m %=60;}
                             if (h >= TIMELINE_END_HOUR && m > 0) { h = TIMELINE_END_HOUR; m = 0; }
                             activeSelection.endTime = String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
                             activeSelection.startTime = slotStartTimeStr;


                        } else if (slotStartTimeStr > firstClickStartTime) {
                            // Второй клик правее первого (или на том же месте)
                            activeSelection.endTime = slotEndTimeStr; // Конец текущего кликнутого слота становится концом диапазона
                        } else {
                            // Клик на тот же самый слот, ничего не меняем в startTime/endTime
                        }
                        highlightTempSelection('gray');
                        // Панель с кнопками цвета уже должна быть видна
                    }
                });

                // Клик по существующему интервалу
                timelineIntervals.querySelectorAll('.timeline-interval-block').forEach(block => {
                    block.addEventListener('click', (event) => {
                        event.stopPropagation(); 
                        handleExistingIntervalClick(block, date, dayCard, controlsPanel, tempSelectionDiv);
                    });
                });

                // Обработчики для панели управления
                controlsPanel.querySelectorAll('.btn-group .btn[data-status]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (!activeSelection) return;

                        // Запрещаем изменение статуса для BOOKED интервалов
                        if (activeSelection.status === 'BOOKED') {
                             // Если это существующий BOOKED, то ничего не делаем
                            if(activeSelection.isExisting) return;
                            // Если это новый слот, который как-то стал BOOKED (через симуляцию), 
                            // то тоже не даем менять цвет кнопками статуса.
                            return; 
                        }

                        const newStatus = btn.dataset.status;
                        
                        // Если кликаем на уже активный статус (и это не начальный выбор слота)
                        // Можно было бы убрать эту проверку, чтобы всегда перерисовывать панель
                        if (activeSelection.status === newStatus && activeSelection.selectionPhase === 'color_picked') {
                           // return; // Пока оставим так, что повторный клик на активный статус ничего не делает
                        }

                        activeSelection.status = newStatus;
                        activeSelection.selectionPhase = 'color_picked'; 

                        highlightTempSelection(activeSelection.status);
                        showControlsPanelForColorPicked(activeSelection.isExisting); 
                        console.log('Status selected/changed to:', activeSelection.status);
                    });
                });

                controlsPanel.querySelector('.action-save').addEventListener('click', handleSave);
                controlsPanel.querySelector('.action-delete').addEventListener('click', handleDelete);
                controlsPanel.querySelector('.action-cancel').addEventListener('click', () => {
                    const previousSelection = JSON.parse(JSON.stringify(activeSelection)); 
                    resetActiveSelection();
                });
            });
        });
        
        function handleExistingIntervalClick(block, date, dayCard, controlsPanel, tempSelectionDiv) {
            resetActiveSelection();
            activeSelection = {
                date: date,
                startTime: block.dataset.startTime,
                endTime: block.dataset.endTime,
                intervalId: block.dataset.intervalId,
                status: block.dataset.status,
                description: block.dataset.description,
                isExisting: true,
                selectionPhase: 'color_picked', // Сразу считаем что цвет выбран (т.к. интервал существует)
                dayCardElement: dayCard,
                tempSlotElement: tempSelectionDiv, // Используем для подсветки при редактировании
                controlsPanel: controlsPanel
            };
            
            highlightTempSelection(activeSelection.status); // Подсветить существующий интервал
            showControlsPanelForColorPicked(true); // true означает, что это существующий интервал
        }


        function highlightTempSelection(colorOrStatus) {
            if (!activeSelection || !activeSelection.tempSlotElement) return;

            const { startTime, endTime, tempSlotElement } = activeSelection; // Убрал status отсюда, он не нужен для размеров
            const totalTimelineMinutes = (TIMELINE_END_HOUR - TIMELINE_START_HOUR) * 60;

            const startH = parseInt(startTime.split(':')[0]);
            const startM = parseInt(startTime.split(':')[1]);
            let endH = parseInt(endTime.split(':')[0]);
            let endM = parseInt(endTime.split(':')[1]);

            // Коррекция для endTime "22:00" - должно покрывать до конца 21:xx
             if (endH === TIMELINE_END_HOUR && endM === 0) {
                // Это значит, что интервал заканчивается в TIMELINE_END_HOUR:00.
                // Для корректного расчета widthPercentage, его конец должен быть на отметке TIMELINE_END_HOUR
             }


            let intervalStartOffsetMinutes = (startH - TIMELINE_START_HOUR) * 60 + startM;
            let intervalEndOffsetMinutes = (endH - TIMELINE_START_HOUR) * 60 + endM;
            
            // Гарантируем, что end offset не меньше start offset
            if (intervalEndOffsetMinutes < intervalStartOffsetMinutes) {
                // Это может произойти, если endTime "00:00" следующего дня, но у нас все в рамках одного дня
                // Или если startTime > endTime из-за ошибки логики выбора диапазона
                // Пока просто делаем их равными, чтобы избежать отрицательной ширины
                console.warn("Corrected intervalEndOffsetMinutes due to being less than intervalStartOffsetMinutes");
                intervalEndOffsetMinutes = intervalStartOffsetMinutes + (60 / SLOTS_PER_HOUR); // мин. ширина 30 мин
            }
             // Ограничение максимальной длины, чтобы не выходило за 22:00
            if (intervalEndOffsetMinutes > totalTimelineMinutes) {
                intervalEndOffsetMinutes = totalTimelineMinutes;
            }


            const leftPercentage = (intervalStartOffsetMinutes * 100.0) / totalTimelineMinutes;
            let widthPercentage = ((intervalEndOffsetMinutes - intervalStartOffsetMinutes) * 100.0) / totalTimelineMinutes;

            if (widthPercentage < 0) widthPercentage = 0; // Защита от отрицательной ширины
            if (leftPercentage + widthPercentage > 100) widthPercentage = 100 - leftPercentage;


            tempSlotElement.style.left = leftPercentage + '%';
            tempSlotElement.style.width = widthPercentage + '%';
            
            // Снимаем предыдущие классы статусов и ставим новый (или серый)
            tempSlotElement.classList.remove('status-available', 'status-unavailable', 'status-undefined', 'status-booked', 'temp-gray-selection');
            if (colorOrStatus === 'gray') {
                tempSlotElement.classList.add('temp-gray-selection');
            } else if (colorOrStatus) { 
                tempSlotElement.classList.add(`status-${colorOrStatus.toLowerCase()}`);
                // tempSlotElement.style.backgroundColor = ''; // Убрал, пусть класс решает
                // tempSlotElement.style.border = ''; // Убрал, пусть класс решает
            }
            
            tempSlotElement.style.display = 'block';
        }

        function showControlsPanelForSlotSelection() {
            if (!activeSelection || !activeSelection.controlsPanel) return;
            const panel = activeSelection.controlsPanel;
            panel.querySelector('textarea').style.display = 'none';
            panel.querySelector('textarea').value = ''; // Очищаем на всякий случай
            panel.querySelector('.action-save').style.display = 'none';
            panel.querySelector('.action-delete').style.display = 'none';
            
            panel.querySelectorAll('.btn-group .btn[data-status]').forEach(b => {
                b.classList.remove('active');
                b.style.display = 'inline-block';
            });
            panel.querySelector('.btn-group').style.display = 'flex'; // Убедимся что группа кнопок видна

            panel.style.display = 'block';
        }

        function showControlsPanelForColorPicked(isInitiallyExistingInterval = false) {
            if (!activeSelection || !activeSelection.controlsPanel) return;
            const panel = activeSelection.controlsPanel;
            const descriptionTextarea = panel.querySelector('textarea');
            const saveButton = panel.querySelector('.action-save');
            const deleteButton = panel.querySelector('.action-delete');
            const statusButtonsGroup = panel.querySelector('.btn-group');

            // Сначала удаляем текстовое отображение статуса, если оно было (для BOOKED)
            const existingStatusDisplayText = panel.querySelector('.status-display-text');
            if(existingStatusDisplayText) existingStatusDisplayText.remove();

            descriptionTextarea.value = activeSelection.description || '';
            descriptionTextarea.style.display = 'block'; // Поле описания всегда видно в этой фазе

            if (activeSelection.status === 'BOOKED') {
                descriptionTextarea.readOnly = true;
                statusButtonsGroup.style.display = 'none'; // Скрываем все кнопки выбора цвета
                saveButton.style.display = 'none';
                deleteButton.style.display = 'none';

                // Отображаем статус как текст (badge)
                const statusDisplay = document.createElement('span');
                statusDisplay.className = 'status-display-text badge me-2';
                statusDisplay.classList.add(activeSelection.status ? `bg-${activeSelection.status.toLowerCase()}` : 'bg-secondary');
                if(activeSelection.status === 'UNDEFINED') statusDisplay.classList.add('text-dark'); else statusDisplay.classList.add('text-white');
                statusDisplay.textContent = activeSelection.status || 'BOOKED'; // Явно показываем BOOKED
                // Вставляем перед группой кнопок (которая скрыта)
                if (!panel.querySelector('.status-display-text')) { // Предотвращаем дублирование, если функция вызвана повторно
                    statusButtonsGroup.insertAdjacentElement('beforebegin', statusDisplay);
                }

            } else { // Статусы AVAILABLE, UNAVAILABLE, UNDEFINED (или новый интервал с выбранным цветом)
                descriptionTextarea.readOnly = false;
                statusButtonsGroup.style.display = 'flex'; 
                
                panel.querySelectorAll('.btn-group .btn[data-status]').forEach(b => {
                    // Кнопки статусов доступны для смены, если интервал не BOOKED
                    b.style.display = 'inline-block'; 
                    if (b.dataset.status === activeSelection.status) {
                        b.classList.add('active');
                    } else {
                        b.classList.remove('active');
                    }
                });

                saveButton.style.display = 'inline-block';
                deleteButton.style.display = (activeSelection.intervalId && activeSelection.status !== 'BOOKED') ? 'inline-block' : 'none';
            }
            panel.style.display = 'block';
        }


        function resetActiveSelection() {
            if (activeSelection) {
                if (activeSelection.tempSlotElement) {
                    activeSelection.tempSlotElement.style.display = 'none';
                    activeSelection.tempSlotElement.classList.remove('status-available', 'status-unavailable', 'status-undefined', 'status-booked', 'temp-gray-selection');
                    activeSelection.tempSlotElement.style.backgroundColor = ''; 
                    activeSelection.tempSlotElement.style.border = ''; 
                }
                if (activeSelection.controlsPanel) {
                    activeSelection.controlsPanel.style.display = 'none';
                    const existingStatusDisplay = activeSelection.controlsPanel.querySelector('.status-display-text');
                    if(existingStatusDisplay) existingStatusDisplay.remove();
                    activeSelection.controlsPanel.querySelector('.btn-group').style.display = 'flex';
                    activeSelection.controlsPanel.querySelector('textarea').readOnly = false;
                    activeSelection.controlsPanel.querySelector('textarea').value = ''; // Очистка textarea
                    activeSelection.controlsPanel.querySelector('.action-save').style.display = 'inline-block'; // Восстанавливаем кнопку сохранить
                    activeSelection.controlsPanel.querySelector('.action-delete').style.display = 'none'; // Скрываем удалить
                    activeSelection.controlsPanel.querySelectorAll('.btn-group .btn[data-status]').forEach(b => b.classList.remove('active'));
                }
            }
            activeSelection = null;
        }

        function handleSave() {
            if (!activeSelection || activeSelection.selectionPhase !== 'color_picked') {
                // Сохраняем только если цвет был выбран
                 if (activeSelection && activeSelection.selectionPhase === 'slot_selected') {
                    alert('Пожалуйста, сначала выберите статус (цвет) для выделенного интервала.');
                 }
                return;
            }
            
            activeSelection.description = activeSelection.controlsPanel.querySelector('textarea').value;

            if (!activeSelection.status) { // Дополнительная проверка, хотя phase 'color_picked' должен это гарантировать
                alert('Пожалуйста, выберите статус интервала (цвет).');
                return;
            }
            
            // Проверка на корректность времени, особенно endTime
            if (activeSelection.startTime >= activeSelection.endTime) {
                alert('Время окончания интервала должно быть позже времени начала.');
                return;
            }


            let url, method, bodyObj;
            if (activeSelection.isExisting) { // Существующий интервал
                url = `/trainer/schedule/interval/update/${activeSelection.intervalId}`;
                method = 'POST'; // Или PUT, если бэкенд настроен
                bodyObj = {
                    // startTime: activeSelection.startTime, // Если разрешаем менять время существующих
                    // endTime: activeSelection.endTime,     // через этот интерфейс
                    status: activeSelection.status,
                    description: activeSelection.description
                };
                 // Если мы позволяем менять время существующих через этот интерфейс, их нужно добавить
                 // и бэкенд должен это поддерживать для /update.
                 // Пока что, по ТЗ, клик на существующий интервал позволяет менять цвет/описание.
                 // Изменение времени существующего интервала может потребовать его удаления и создания нового,
                 // или отдельного, более сложного UI.
            } else { // Новый интервал
                url = '/trainer/schedule/interval/add';
                method = 'POST';
                bodyObj = {
                    trainerId: trainerId, 
                    date: activeSelection.date,
                    startTime: activeSelection.startTime,
                    endTime: activeSelection.endTime,
                    status: activeSelection.status,
                    description: activeSelection.description
                };
            }

            const headers = new Headers();
            if (csrfToken && csrfHeaderName) headers.append(csrfHeaderName, csrfToken);
            // Бэкенд ожидает application/x-www-form-urlencoded, так что Content-Type должен быть соответствующим
            headers.append('Content-Type', 'application/x-www-form-urlencoded');


            fetch(url, {
                method: method,
                headers: headers,
                body: new URLSearchParams(bodyObj).toString()
            })
            .then(async response => {
                if (!response.ok) {
                    // Попробуем прочитать ошибку как JSON, если не получится - общая ошибка
                    let errorText = `Ошибка ${response.status}`;
                    try {
                        const errorData = await response.json();
                        if (errorData && errorData.error) {
                             errorText = errorData.error;
                        } else if (errorData && errorData.message) {
                             errorText = errorData.message;
                        } else if (typeof errorData === 'string') {
                            errorText = errorData;
                        }
                    } catch (e) {
                        // не удалось распарсить JSON, используем response.statusText
                        errorText = response.statusText || errorText;
                    }
                    throw new Error(errorText);
                }
                return response.json();
            })
            .then(data => {
                resetActiveSelection();
                window.location.reload(); 
            })
            .catch(error => {
                console.error('Ошибка при сохранении:', error);
                alert(`Не удалось сохранить интервал: ${error.message}`);
                // Не сбрасывать выделение, чтобы пользователь мог исправить или повторить
                // Но если ошибка из-за пересечения, то может и стоит сбросить или дать другой фидбек
            });
        }

        function handleDelete() {
            if (!activeSelection || !activeSelection.isExisting || !activeSelection.intervalId) {
                alert('Не выбран интервал для удаления.');
                return;
            }
            if (!confirm('Вы уверены, что хотите удалить этот интервал?')) return;

            const url = `/trainer/schedule/interval/${activeSelection.intervalId}`;
            const headers = new Headers();
            if (csrfToken && csrfHeaderName) headers.append(csrfHeaderName, csrfToken);

            fetch(url, { method: 'DELETE', headers: headers })
            .then(async response => {
                 if (!response.ok) {
                    let errorText = `Ошибка ${response.status}`;
                    try {
                        const errorData = await response.json();
                         if (errorData && errorData.error) {
                             errorText = errorData.error;
                        } else if (errorData && errorData.message) {
                             errorText = errorData.message;
                        } else if (typeof errorData === 'string') {
                            errorText = errorData;
                        }
                    } catch (e) {
                         errorText = response.statusText || errorText;
                    }
                    throw new Error(errorText);
                }
                // Бэкенд должен вернуть JSON в случае успеха, даже если это пустой объект или {success: true}
                // Если бэкенд возвращает 204 No Content, то response.json() вызовет ошибку.
                // Проверяем статус, если 204, то считаем успехом.
                if (response.status === 204) {
                    return { success: true }; // Симулируем успешный JSON ответ
                }
                return response.json();
            })
            .then(data => {
                // data может быть не определено если был 204
                console.log('Интервал удален:', data);
                resetActiveSelection();
                window.location.reload();
            })
            .catch(error => {
                console.error('Ошибка удаления:', error);
                alert(`Не удалось удалить интервал: ${error.message}`);
            });
        }
        
        // Стиль для временного серого выделения, если не хотим через класс
        // const styleSheet = document.createElement("style");
        // styleSheet.type = "text/css";
        // styleSheet.innerText = ".temp-gray-selection { background-color: rgba(108, 117, 125, 0.5) !important; border: 1px dashed #6c757d !important; }";
        // document.head.appendChild(styleSheet);


        /*]]>*/
    </script>
</body>
</html> 